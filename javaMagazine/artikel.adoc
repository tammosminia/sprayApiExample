= Een REST API maken met Akka HTTP

== Akka

Akka is een framework waarin je Actors maakt die met elkaar communiceren door middel van Messages.
In een eerdere editie zijn Akka en het bijhorende actor model al uitgebreid toegelicht (zie http://www.nljug.org/databasejava/akka/). +
Dit artikel ligt toe hoe je met behulp van een subproject van Akka, Akka Http (voorheen Spray) eenvoudige restful api's kunt ontwikkelen.

== Akka HTTP

Akka HTTP is een subproject van Akka dat zorgt voor communicatie met de buitenwereld, door middel van HTTP.
Vroeger heette dit Spray en deze naam zal ook nog in wat dependencies en packages terugkomen. +
De artifact-naam is nog *akka-http-experimental*. Maar laat je hierdoor niet afschrikken.
Dit is omdat er nog wijzigingen op de interface kunnen komen. Het draait al wel stabiel genoeg om in productie te gebruiken.

We gaan hier een simpele REST API maken, de Robots API. Er wordt een lijst van robots bijgehouden, waar je robots aan kunt toevoegen en verwijderen.

Je maakt een robot met een POST naar http://localhost:8080/robots

Je kunt alle robots opvragen met een GET naar http://localhost:8080/robots

Verwijderen doe je met DELETE naar http://localhost:8080/robots/R2D2
We gebruiken hier de naam (in dit geval: 'R2D2') om een robot te identificeren.


== Build en dependencies

We gebruiken natuurlijk het nieuwste van het nieuwste, Scala 2.11.7 en Akka 2.4.4. +
Het lijkt voor de hand te liggen om SBT (Scala Build Tool) te gebruiken. Dit is echter helemaal niet noodzakelijk. Je kunt ook gewoon Gradle of Maven gebruiken. +
Let op de _2.11 in de dependencies. Met SBT is het niet nodig om die voluit te schrijven, dan wordt het erachter geplakt door %% te gebruiken ipv %.
Zoals in "com.typesafe.akka" %% "akka-http-core" % "2.4.4". Hier wordt dan impliciet akka-http-core_2.11 gebruikt. +
Er zijn ook versies gecompileerd voor oudere Scala versies. Die hebben wij niet nodig. +
Je Gradle build-file ziet er dan als volgt uit:

[source]
----
apply plugin: 'scala'
apply plugin: 'application'

repositories {
    mavenCentral()
}

ext {
    akkaVersion = "2.4.4"
}

dependencies {
    compile group: 'org.scala-lang', name: 'scala-library', version: '2.11.7'
    compile group: 'com.typesafe.akka', name: 'akka-actor_2.11', version: akkaVersion
    compile group: 'com.typesafe.akka', name: 'akka-http-experimental_2.11', version: akkaVersion
    compile group: 'com.typesafe.akka', name: 'akka-http-spray-json-experimental_2.11', version: akkaVersion
}

mainClassName = "RobotsApiApp"
----

== Routes en Directives

Het hart van Akka HTTP is de Route. Dit bepaalt wat er uiteindelijk gebeurt met de binnenkomende requests.
De Route wordt opgebouwd met behulp van Directives: kleine eenvoudige bouwblokken die je in elkaar kunt nesten of naast elkaar kunt zetten met *~*.

Akka levert standaard al een aantal Directives voor allerlei verschillende doeleinden. Bijvoorbeeld:

- Controle van de HTTP methode: o.a. get, post
- Extractie van parameters: parameters
- Extractie van headers: headerValueByName
- Authenticatie: authenticateBasic
- Marshalling: complete, entity, handleWith

In het voorbeeld zie je dat we eerst splitsen op het URL-pad. Bij een leeg pad (http://localhost:8080/) geven we de API documentatie terug.
En onder "robots" splitsen we aan de hand van de HTTP methode, zodat je de correcte handeling kunt doen.
Met *complete* geven we het antwoord terug. Nu nog in de vorm van eenvoudige tekst.

Voor de DELETE lezen we het laatste stukje URL-pad, dat is de naam van de robot.

Je route ziet er dan als volgt uit:
[source]
----
val route: Route =
  pathPrefix("robots") {
    get {
      complete("Lijst met alle robots")
    } ~ post {
      complete("Voeg een robot toe")
    } ~ delete {
      path(Segment) { naam =>
        complete(s"Verwijder robot $naam")
      }
    }
  } ~ path("") {
    complete("Robots API documentatie")
  }
----

De werking hiervan kun je testen met curl:
[source]
----
$ curl http://localhost:8080
Robots API documentatie
$ curl -X POST http://localhost:8080/robots
Voeg een robot toe
$ curl -X DELETE http://localhost:8080/robots/Asimo
Verwijder robot Asimo
----

== Marshalling

Nu gaan we een domeinobject aanmaken dat naar JSON kan worden gemarshalled.

[source]
----
case class Robot(naam: String, kleur: Option[String], aantalArmen: Int) {
  require(aantalArmen >= 0, "Robots kunnen geen negatief aantal armen hebben!")
}
----

In onze API houden we de lijst met bekende robots bij. Die vullen we voor het gemak alvast met twee robots:

[source]
----
var robots = List(Robot("R2D2", Some("wit"), 0), Robot("Asimo", None, 2))
----

Akka weet al hoe de standaard klassen (zoals String, List, Int) moeten worden gemarshalled. +
Voor onze domein klasse moet je een impliciete variabele toevoegen.
De 3 staat hier voor het aantal instance variabelen dat Robot heeft (naam, kleur en aantalArmen).

[source]
----
implicit val RobotFormat = jsonFormat3(Robot)
----

Nu is Akka in staat om robots te marshallen naar JSON, en te unmarshallen vanuit JSON. Met *complete* kunnen we nu simpelweg de lijst met robots teruggeven.
Voor de POST gebruiken we *handleWith*. Dit vertaalt de input naar ons domeinobject en het vertaalt ook het uiteindelijke resultaat weer naar JSON.
We geven hier de nieuwe robot weer terug.

[source]
----
 val route: Route =
    path("robots") {
      get {
        complete(robots)
      } ~ post {
        handleWith { robot: Robot =>
          robots = robot :: robots
          robot
        }
      }
    } ~ path("") {
      complete("Robots API documentatie")
    }
----

We gaan dit weer testen met curl.

[source]
----
$ curl http://localhost:8080/robots
[{
  "name": "R2D2",
  "color": "white",
  "amountOfArms": 0
}, {
  "name": "Asimo",
  "amountOfArms": 2
}]

$ curl -H "Content-Type: application/json" -X POST -d '{"naam": "C3PO", "kleur": "goud", "aantalArmen": 2}' http://localhost:8080/robots
{
  "naam": "C3PO",
  "kleur": "goud",
  "aantalArmen": 2
}
----

== Validatie

Als je ongeldige input geeft, dan krijg je ook netjes foutmeldingen terug.
Als je een *String* mee geeft waar een *Int* hoort.

[source]
----
$ curl -H "Content-Type: application/json" -X POST -d '{"naam": "C3PO", "kleur": "goud", "aantalArmen": "veel"}' http://localhost:8080/robots
The request content was malformed:
Expected Int as JsNumber, but got "veel"
----

Kleur is een optioneel veld, dus die hoef je niet mee te geven. De andere velden zijn wel verplicht.

[source]
----
$ curl -H "Content-Type: application/json" -X POST -d '{"kleur": "groen", "aantalArmen": "1"}' http://localhost:8080/robots
The request content was malformed:
Object is missing required member 'naam'
----

In de Robots klasse hebben we een requirement toegevoegd. Ook deze wordt netjes gecontroleerd en doorgegeven.

[source]
----
$ curl -H "Content-Type: application/json" -X POST -d '{"naam": "C3PO", "kleur": "goud", "aantalArmen": -1}' http://localhost:8080/robots
requirement failed: Robots kunnen geen negatief aantal armen hebben!
----

== Opstarten van de API

Er zijn verschillende manieren om de API te starten. +
Lokaal is het waarschijnlijk het eenvoudigst om het te starten vanuit je IDE. +
In build.gradle hebben we de *application* plugin toegevoegd. Dit maakt het mogelijk om de applicatie te starten met behulp van het commando: *gradle run*. +
Je kunt een (fat) JAR maken die je start met *java -jar*. +
Vroeger kon je met spray-servlet zorgen dat spray als een servlet draait op een Tomcat server. Dit maakte echter veel snelheidsvoordelen van Akka ongedaan.
Daarom wordt dit niet meer ondersteund.

== Configuratie

Akka leest zijn configuratie standaard uit *application.conf*.
Dit is in HOCON formaat. Daarmee is het eenvoudig om een gestructureerde configuratie te maken.

Je kunt hier Akka defaults overschrijven. We zetten nu het loglevel wat omhoog. +
Ook kun je hier prima je eigen configuratie instellingen in kwijt, zoals het poortnummer waar de API op luistert.

[source]
----
port = 8080
akka {
  loglevel = "DEBUG"
}
----

Deze configuratie is vervolgens uit te lezen in je Actor met:
[source]
----
val port = system.settings.config.getInt("port")
----


== Logging

Met het directive *logRequestResult* kunnen we alle requests en responses loggen.
Ook kun je zelf logging toevoegen met *system.log.info*. +
Als je nu een request doet, zie je dat mooi in de logging.

[source]
----
[INFO] [04/27/2016 14:16:32.534] [RobotSystem-akka.actor.default-dispatcher-4] [akka.actor.ActorSystemImpl(RobotSystem)] We hebben nu 3 robots.
[DEBUG] [04/27/2016 14:16:32.558] [RobotSystem-akka.actor.default-dispatcher-4] [akka.actor.ActorSystemImpl(RobotSystem)] RobotsAPI: Response for
  Request : HttpRequest(HttpMethod(POST),http://localhost:8080/robots,List(User-Agent: curl/7.38.0, Host: localhost:8080, Accept: */*, Timeout-Access: <function1>),HttpEntity.Strict(application/json,{"naam": "C3PO", "kleur": "goud", "aantalArmen": 2}),HttpProtocol(HTTP/1.1))
  Response: Complete(HttpResponse(200 OK,List(),HttpEntity.Strict(application/json,{
  "naam": "C3PO",
  "kleur": "goud",
  "aantalArmen": 2
}),HttpProtocol(HTTP/1.1)))
----

== De complete code

Naast de build file is dit de enige code die nodig is om de API te draaien. Dit is ook te vinden op GitHub: https://github.com/tammosminia/sprayApiExample/tree/javaMagazine/robotsApi.

[source]
----

import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.Route
import akka.stream.ActorMaterializer
import akka.util.Timeout
import spray.json.DefaultJsonProtocol
import scala.concurrent.ExecutionContext
import scala.concurrent.duration._

case class Robot(naam: String, kleur: Option[String], aantalArmen: Int) {
  require(aantalArmen >= 0, "Robots kunnen geen negatief aantal armen hebben!")
}

object RobotsApiApp extends App with SprayJsonSupport with DefaultJsonProtocol {
  implicit val system = ActorSystem("RobotSystem")
  implicit val materializer = ActorMaterializer()
  implicit val executionContext: ExecutionContext = system.dispatcher
  implicit val timeout = Timeout(5.seconds)
  val port = system.settings.config.getInt("port")

  implicit val RobotFormat = jsonFormat3(Robot)

  var robots = List(Robot("R2D2", Some("wit"), 0), Robot("Asimo", None, 2))

  val route: Route = logRequestResult("RobotsAPI") {
    pathPrefix("robots") {
      get {
        complete(robots)
      } ~ post {
        handleWith { robot: Robot =>
          robots = robot :: robots
          system.log.info(s"We hebben nu ${robots.size} robots.")
          robot
        }
      } ~ delete {
        path(Segment) { naam =>
          robots = robots.filter { _.naam != naam }
          complete(s"robot $naam verwijderd")
        }
      }
    } ~ path("") {
      complete("Robots API documentatie")
    }
  }

  val bindingFuture = Http().bindAndHandle(route, "localhost", port)
  println(s"Robots API - http://localhost:$port/")
}
----

== Biografie

image::profielfoto.jpg[Tammo,300,300]

Tammo is een programmeur die werkt bij JDriven. Na veel ervaring met Java en Groovy, maakt hij nu mooie dingen in Scala.
